{"title":"group_assignment","markdown":{"yaml":{"title":"group_assignment","fig-dpi":600},"headingText":"INTRODUCTION","containsRefs":false,"markdown":"\n\n\n\\[PLATZHALTER\\]\n\n# Data and Methodology\n\n\\[PLATZHALTER\\]\n\nAnmerkungen\n\nErstellung eines neuen Dataframes mit Returns aller Aktien.\n\nCRSP gibt arithmetische Renditen aus. Diese transformieren wir in logrithmierte. Die Returns sind bereits adjusted, d.h. Dividenden sind bereits berücksichtigt.\n\nNormierte preise auf Basis der Renditen berechnen.\n\nPreise sind nicht adjustiert. Wir werden die Kurse auf Basis der Renditen plotten - alle auf 100 normieren und dann mit den returns multiplizieren (vereinfacht das adjustment um die Dividenden - wir haben monatliche returns, dividend payments fallen damit nicht immer auf den selben tag)\n\nFolgende Preise sind \"simuliert\" für den Plot. Achtung: preis startet am 29.8.2014 bei 100 die return am 29.8.2014 bezieht sich aber auf Preis(29.8.2014) / Preis(28.8.2014).\n\n```{r echo = FALSE, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(moments)\nlibrary(slider)\nlibrary(tidyquant)\nlibrary(PortfolioAnalytics)\nlibrary(PerformanceAnalytics)\nlibrary(ROI)\nlibrary(ROI.plugin.quadprog)\nlibrary(writexl)\nlibrary(broom)\n```\n\n```{r echo = FALSE, message=FALSE, warning=FALSE}\ndata_raw <- read_xlsx(\"data/stocks.xlsx\")\n# glimpse(data_raw)\n\n# risikoloser zins\ninvisible(getSymbols(\"DTB3\", src = \"FRED\"))\n\n# risikoloser zins in richtiges format bringen\ndtb3 <- tibble(\n  date = index(DTB3),\n  rate = as.numeric(DTB3)\n) %>%\n  filter(!is.na(rate)) %>%\n  filter(date >= as.Date(\"2014-08-29\"), date <= as.Date(\"2024-08-30\")) %>%\n  mutate(\n    rF_annual = rate / 100,\n    rF_monthly = (1 + rF_annual)^(1/12)-1,\n    month = as.Date(format(date, \"%Y-%m-01\"))\n    ) %>%\n  group_by(month) %>%\n  slice_tail(n = 1) %>%\n  ungroup() %>%\n  select(date, rF_monthly)\n  \n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Funkion für Darstellung der Dataframes | kann man ignorieren\n\ndataframe_fancy <- function(df) {\n  tibble(\n    Variable = names(df),\n    Datentyp = sapply(df, class),\n    Wert = sapply(df, function(x) {\n      as.character(x[!is.na(x)][1])\n    })\n  ) %>%\n    knitr::kable(\n      col.names = c(\"Variable\", \"Datentyp\", \"Wert\"),\n      align = c(\"l\", \"l\", \"l\")\n    )\n}\n\n```\n\n```{r echo = FALSE}\n# dataframe für returns\n\nreturns <- data_raw %>%\n  select(permno = PERMNO,\n         ticker = `Ticker Symbol`,\n         company = `Company Name`,\n         date = `Names Date`,\n         returns = Returns) %>%\n  arrange(ticker, date) %>%\n  mutate(returns_log = log(1 + returns))\n  \n# dataframe_fancy(returns)\n\n\n```\n\n```{r echo=FALSE}\nticker = returns %>% distinct(ticker)\n\nprices <- returns %>%\n  group_by(ticker) %>%\n  arrange(date) %>%\n  mutate(prices = 100 * exp(cumsum(returns_log)) / first(exp(cumsum(returns_log)))) %>%\n  arrange(ticker, date) %>%\n  ungroup()\n\n# dataframe_fancy(prices)\n```\n\n# Descriptive Analysis of Indiviudal Stocks\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE}\n\n\n# plot für alle aktien\nggplot(prices, aes(x = date, y = prices, color = ticker)) +\n  geom_line(linewidth = 0.5) +\n  scale_y_log10() +\n  labs(title = \"Stock Prices\",\n       x = \"Date\",\n       y = \"Prices log\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n```\n\n## Return and Risk Characteristics\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE}\nmax_drawdown <- prices %>%\n  group_by(ticker) %>%\n  mutate(\n    running_max = cummax(prices),\n    drawdown = prices / running_max - 1\n  ) %>%\n  summarise(max_drawdown = min(drawdown, na.rm=TRUE))\n\nstatistics_stocks <- returns %>%\n  group_by(ticker) %>%\n  summarise(\n    mean_return = mean(returns, na.rm = TRUE),\n    sd_return   = sd(returns, na.rm = TRUE),\n    min_return  = min(returns, na.rm = TRUE),\n    max_return  = max(returns, na.rm = TRUE)\n  ) %>%\n  left_join(max_drawdown, by = \"ticker\")\n\nstatistics_stocks %>%\n  mutate(\n    mean_return = mean_return * 100 * 12,\n    sd_return = sd_return * 100 * sqrt(12),\n    min_return = min_return * 100,\n    max_return = max_return * 100,\n    max_drawdown = max_drawdown * 100\n  ) %>%\n  kable(col.names = c(\"Ticker\", \"Ø Return (%) p.a.\", \"Std.Dev. (%) p.a.\", \"Minimum (%)\", \"Maximum (%)\", \"Max Drawdown (%)\"),\n        digits = 2)\n```\n\n## Distributional Properties of Returns\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ndistribution_stocks <- returns %>%\n  group_by(ticker) %>%\n  summarise(\n    skewness = skewness(returns_log, na.rm = TRUE),\n    kurtosis = kurtosis(returns_log, na.rm = TRUE)\n  ) %>%\n  mutate(skewness_int = case_when(\n      skewness > 0 ~ \"positively skewed\",\n      skewness == 0 ~ \"symmetric\",\n      skewness < 0 ~ \"negatively skewed\"\n      ),\n      kurtosis_int = case_when(\n        kurtosis < 0 ~ \"platykurtic\",\n        kurtosis > 0 ~ \"leptokurtic\",\n        kurtosis == 0 ~ \"norm. distributed\"\n      )\n      )\n\ndistribution_stocks %>%\n  select(ticker, skewness, skewness_int, kurtosis, kurtosis_int) %>%\n  kable(col.names = c(\"Ticker\", \"Skewness\", \"Interpretation\", \"Excess Kurtosis\", \"Interpretation\"))\n```\n\n## Time-Varying Risk and Performance\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nvola_rolling <- returns %>%\n  group_by(ticker) %>%\n  arrange(date) %>%\n  mutate(\n    roll_sd = slide_dbl(\n      returns_log,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd_annual = roll_sd * sqrt(12)\n  ) %>%\n  select(-c(\"permno\", \"company\", \"returns\", \"returns_log\"))\n\n\nggplot(vola_rolling,\n       aes(x = date, y = roll_sd_annual, group = ticker, color = ticker)) +\n  geom_line(alpha = 0.5) +\n  labs(\n    title = \"12 month rolling Volatility (annual)\",\n    x = \"Date\",\n    y = \"Rolling Volatility\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n```\n\n```{r message=FALSE, warning=FALSE, echo=FALSE}\n# Leider fehlende Werte von rF_monthly für 2024-03-28 ; 2018-03-29 ; 2021-05-28\n# Letzten Tag im Monat genommen\n\nexcess_return <- returns %>%\n  mutate(month = as.Date(format(date, \"%Y-%m-01\"))) %>%\n  left_join(\n    dtb3 %>%\n      mutate(month = as.Date(format(date, \"%Y-%m-01\"))),\n    by = \"month\"\n  ) %>%\n  mutate(excess_return = returns - rF_monthly)\n\n\nsharpe_ratio_rolling <- excess_return %>%\n  group_by(ticker) %>%\n  arrange(date.x) %>%\n  mutate(\n    roll_mean_excess = slide_dbl(\n      excess_return,\n      mean,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd = slide_dbl(\n      returns,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    sharpe_ratio_rolling = (roll_mean_excess / roll_sd) * sqrt(12)\n  ) %>%\n  ungroup()\n\nggplot(sharpe_ratio_rolling, aes(x = date.x, y = sharpe_ratio_rolling, group = ticker, color = ticker)) +\n  geom_line(alpha = 0.5) +\n  labs(title = \"12 month Rolling Sharpe Ratios\", x = \"Date\", y = \"SR (annualized)\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n\n```\n\n## Total Set of Stocks (Equally Weighted)\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE}\n# ew = equal weights\nportfolio_ew <- excess_return %>%\n  group_by(date.x) %>%\n  summarise(\n    portfolio_ew_return = mean(returns, na.rm = TRUE),\n    portfolio_ew_excess_return = mean(excess_return, na.rm = TRUE)\n  ) %>%\n  ungroup()\n\nportfolio_ew_prices <- portfolio_ew %>%\n  arrange(date.x) %>%\n  mutate(portfolio_price = 100 * exp(cumsum(log(1 + portfolio_ew_return))) / first(exp(cumsum(log(1 + portfolio_ew_return)))))\n\n# dataframe_fancy(portfolio_ew)\n# dataframe_fancy(portfolio_ew_prices)\n```\n\n```{r echo=FALSE}\nggplot() +\n  # Einzelaktien (grau, Hintergrund)\n  geom_line(\n    data = prices,\n    aes(x = date, y = prices, group = ticker),\n    color = \"grey70\",\n    alpha = 0.4,\n    linewidth = 0.5\n  ) +\n  # Portfolio (schwarz, Vordergrund)\n  geom_line(\n    data = portfolio_ew_prices,\n    aes(x = date.x, y = portfolio_price),\n    color = \"black\",\n    linewidth = 1.2\n  ) +\n  scale_y_log10() +\n  labs(\n    title = \"Stock Performance vs. Equal-Weighted Portfolio\",\n    subtitle = \"Grey lines = individual stocks, black line = equal-weighted portfolio\",\n    x = \"Date\",\n    y = \"Index (start = 100)\"\n  ) +\n  theme_minimal()\n\nreturns_wide <- returns %>%\n  group_by(ticker, date) %>%\n  summarise(returns = mean(returns, na.rm = TRUE),\n            .groups = \"drop\") %>%\n  pivot_wider(\n    names_from = ticker,\n    values_from = returns\n  ) %>%\n  arrange(date)\n\ncor_matrix <- returns_wide %>%\n  select(-date) %>%\n  cor(use = \"pairwise.complete.obs\")\n\ncor_long <- cor_matrix %>%\n  as.data.frame() %>%\n  rownames_to_column(\"Stock1\") %>%\n  pivot_longer(\n    -Stock1,\n    names_to = \"Stock2\",\n    values_to = \"Correlation\"\n  )\n\nggplot(cor_long, aes(x = Stock2, y = Stock1, fill = Correlation)) +\n  geom_tile(color = \"white\", linewidth = 0.4) +\n  geom_text(\n    aes(label = sprintf(\"%.2f\", Correlation)),\n    size = 1.5,\n    color = \"black\"\n  ) +\n  scale_fill_gradient(\n    low = \"#e5f5e0\",\n    high = \"#238b45\",\n    limits = c(-1, 1),\n    name = \"Correlation\"\n  ) +\n  labs(\n    title = \"Correlation Matrix of Monthly Stock Returns\"\n  ) +\n  theme_minimal(base_size = 11) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    axis.title = element_blank(),\n    panel.grid = element_blank()\n  )\n\n```\n\n## Return and Risk Characteristics of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo = FALSE}\nstatistics_portfolio_ew <- portfolio_ew %>%\n  summarise(\n    mean_return = mean(portfolio_ew_return, na.rm = TRUE) * 12 * 100,\n    sd_return   = sd(portfolio_ew_return, na.rm = TRUE) * sqrt(12) * 100,\n    min_return  = min(portfolio_ew_return, na.rm = TRUE) * 100,\n    max_return  = max(portfolio_ew_return, na.rm = TRUE) * 100\n  )\n\nportfolio_ew_drawdown <- portfolio_ew_prices %>%\n  arrange(date.x) %>%\n  mutate(\n    running_max = cummax(portfolio_price),\n    drawdown = portfolio_price / running_max - 1\n  ) %>%\n  summarise(max_drawdown = min(drawdown, na.rm =TRUE)) * 100\n\nstatistics_portfolio_ew <- statistics_portfolio_ew %>%\n  mutate(max_drawdown = portfolio_ew_drawdown$max_drawdown)\n\nstatistics_portfolio_ew <- statistics_portfolio_ew %>%\n  mutate(\n    sharpe_ratio = (\n      mean(portfolio_ew$portfolio_ew_return - dtb3$rF_monthly, na.rm = TRUE) /\n      sd(portfolio_ew$portfolio_ew_return, na.rm = TRUE)\n    )\n  )\n\n\n\nstatistics_portfolio_ew %>%\n  kable(\n    col.names = c(\n      \"Ø Return (% p.a.)\",\n      \"Volatility (% p.a.)\",\n      \"Minimum (%)\",\n      \"Maximum (%)\",\n      \"Max Drawdown (%)\",\n      \"Sharpe Ratio p.m.\"\n    ),\n    digits = 2\n  )\n\n```\n\n### Rolling Volatility of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo = FALSE, warning=FALSE}\nportfolio_ew_vola_rolling <- portfolio_ew %>%\n  arrange(date.x) %>%\n  mutate(\n    roll_sd = slide_dbl(\n      portfolio_ew_return,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd_annual = roll_sd * sqrt(12)\n  )\n\nggplot(portfolio_ew_vola_rolling,\n       aes(x = date.x, y = roll_sd_annual)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  labs(\n    title = \"12-Month Rolling Volatility – Equal-Weighted Portfolio\",\n    x = \"Date\",\n    y = \"Volatility (% p.a.)\"\n  ) +\n  theme_minimal()\n\n\n```\n\n### Rolling Sharpe Ratio of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo = FALSE, warning=FALSE}\nportfolio_ew_sharpe_rolling <- portfolio_ew %>%\n  arrange(date.x) %>%\n  mutate(\n    roll_mean_excess = slide_dbl(\n      portfolio_ew_excess_return,\n      mean,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd = slide_dbl(\n      portfolio_ew_return,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    sharpe_12m = (roll_mean_excess / roll_sd) * sqrt(12)\n  )\n\nggplot(portfolio_ew_sharpe_rolling,\n       aes(x = date.x, y = sharpe_12m)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  labs(\n    title = \"12-Month Rolling Sharpe Ratio – Equal-Weighted Portfolio\",\n    x = \"Date\",\n    y = \"Sharpe Ratio (annualized)\"\n  ) +\n  theme_minimal()\n\n```\n\n### Subperiod Analyis of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\n# Sub period analysis\ncovid_date <- as.Date(\"2020-02-01\")\n\n# Covid crash\nggplot(portfolio_ew_prices, aes(x = date.x, y = portfolio_price)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  geom_vline(\n    xintercept = covid_date,\n    linetype = \"dashed\",\n    color = \"darkred\",\n    linewidth = 0.8\n  ) +\n  annotate(\n    \"text\",\n    x = covid_date,\n    y = max(portfolio_ew_prices$portfolio_price, na.rm = TRUE),\n    label = \"COVID-19\",\n    vjust = -0.5,\n    hjust = -0.1,\n    color = \"darkred\",\n    size = 4\n  ) +\n  labs(\n    title = \"Equal-Weighted Portfolio Performance\",\n    subtitle = \"COVID-19 period highlighted\",\n    x = \"Date\",\n    y = \"Portfolio Value (Base = 100)\"\n  ) +\n  theme_minimal()\n\n# kennzahlen subperioden\nportfolio_ew_sub <- portfolio_ew %>%\n  mutate(\n    period = if_else(\n      date.x < as.Date(\"2020-01-01\"),\n      \"Pre-COVID (2014–2019)\",\n      \"Post-COVID (2020–2024)\"\n    )\n  )\n\nportfolio_ew_stats_sub <- portfolio_ew_sub %>%\n  group_by(period) %>%\n  summarise(\n    mean_return_pa = mean(portfolio_ew_return, na.rm = TRUE) * 12 * 100,\n    volatility_pa  = sd(portfolio_ew_return, na.rm = TRUE) * sqrt(12) * 100,\n    sharpe_ratio   = mean(portfolio_ew_excess_return, na.rm = TRUE) /\n                     sd(portfolio_ew_return, na.rm = TRUE) * sqrt(12),\n    .groups = \"drop\"\n  )\n\nportfolio_ew_dd_sub <- portfolio_ew_prices %>%\n  mutate(\n    period = if_else(\n      date.x < as.Date(\"2020-01-01\"),\n      \"Pre-COVID (2014–2019)\",\n      \"Post-COVID (2020–2024)\"\n    )\n  ) %>%\n  group_by(period) %>%\n  summarise(\n    max_drawdown = min(portfolio_price / cummax(portfolio_price) - 1, na.rm = TRUE) * 100,\n    .groups = \"drop\"\n  )\n\nportfolio_ew_table_sub <- portfolio_ew_stats_sub %>%\n  left_join(portfolio_ew_dd_sub, by = \"period\") %>%\n  mutate(\n    across(where(is.numeric), round, 2)\n  )\n\nkable(\n  portfolio_ew_table_sub,\n  col.names = c(\n    \"Period\",\n    \"Ø Return (% p.a.)\",\n    \"Volatility (% p.a.)\",\n    \"Sharpe Ratio\",\n    \"Max Drawdown (%)\"\n  ),\n  caption = \"Subperiod Analysis of the Equal-Weighted Portfolio\"\n)\n\n```\n\n# Portfolio formation\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nrF_portfolio_chart = mean(dtb3$rF_monthly, na.rm = TRUE)\n\n# Portfolioanalyse mit PortfolioAnalytics\nR <- xts(\n  returns_wide %>% select(-date),\n  order.by = returns_wide$date\n)\n\n\n# portfolio objekt erstellen\nport <- portfolio.spec(colnames(R))\n\n# Voll investieren, shortselling erlaubt\nport <- add.constraint(port, type = \"full_investment\")\nport <- add.constraint(port, type = \"long_only\")\n\n# objectives definieren\nport <- add.objective(port, type = \"risk\", name = \"StdDev\")\nport <- add.objective(port, type = \"return\", name = \"mean\")\n\n# efficient frontier berechnen\nef <- create.EfficientFrontier(\n  R = R,\n  portfolio = port,\n  type = \"mean-StdDev\",\n  n.portfolios = 50\n)\n\nport_sr <- add.objective(\n  port,\n  type = \"risk_adjusted_return\",\n  name = \"SharpeRatio\",\n  arguments = list(Rf = rF_portfolio_chart)\n)\n\n# maxST = TRUE! um marktportfolio zu bestimmen\ntan <- optimize.portfolio(\n  R = R,\n  portfolio = port_sr,\n  optimize_method = \"ROI\",\n  maxSR = TRUE\n)\n\n\nchart.EfficientFrontier(\n  ef,\n  chart.tangent = TRUE,\n  match.col = \"StdDev\",\n  risk.col = \"StdDev\",\n  return.col = \"mean\",\n  chart.assets = TRUE,\n  chart.CML = TRUE,\n  rf = rF_portfolio_chart,\n  col = \"darkred\"\n)\n\n\n# Gewichte\nweights_tangential_portfolio <- as.data.frame(extractWeights(tan)) %>% rownames_to_column(var =\"ticker\")\ncolnames(weights_tangential_portfolio) <- c(\"Ticker\", \"Weights\")\n\n\n# Rendite und vola\nstats_tangential_portfolio <- as.data.frame(extractObjectiveMeasures(tan))\nrownames(stats_tangential_portfolio) <- \"Market Portfolio p.m.\"\ncolnames(stats_tangential_portfolio) <- c(\"St. Dev.\", \"Return\")\n\n# rf ist funktion, muss definiert werden\nrf_SR <- 0.001332711\n\nSharpeRatio = (as.numeric(extractObjectiveMeasures(tan)$mean) - rf_SR) / as.numeric(extractObjectiveMeasures(tan)$StdDev)\n\nstats_tangential_portfolio$`Sharpe Ratio` = SharpeRatio\n\nstats_tangential_portfolio <- rbind(\n  stats_tangential_portfolio,\n  \"Market Portfolio p.a.\" = c(\n    stats_tangential_portfolio$`St. Dev.` * sqrt(12),\n    (1 + stats_tangential_portfolio$Return)^(12)-1,\n    stats_tangential_portfolio$`Sharpe Ratio` * sqrt(12))\n  )\n\n# output als tabelle\nkable(stats_tangential_portfolio)\n\n\n# tabelle für gewichte\nh <- ceiling(nrow(weights_tangential_portfolio)/2)\n\nkable(\n  cbind(weights_tangential_portfolio[1:h, ], weights_tangential_portfolio[(h+1):nrow(weights_tangential_portfolio), ][1:h, ]),\n  col.names = c(\"Ticker\",\"Weight\",\"Ticker\",\"Weight\")\n)\n\n\n# Unterschiedliche Lösungen in Excel und Portfolioanalytics. Grund: Gewichtungen sind anders\n# (solve(cov(R)) %*% (colMeans(R)-rf_SR)) / sum((solve(cov(R)) %*% (colMeans(R)-rf_SR)))\n\n\n\n```\n\n## Performance of Optimized Portfolio vs Single Stocks\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nportfolio_op_return_plot <- Return.portfolio(\n  R,\n  weights = extractWeights(tan),\n  rebalance_on = NA\n)\n\n\ncharts.PerformanceSummary(\n  R = merge(portfolio_op_return_plot, R)[\"2014-08-29/2024-08-30\"],\n  main = \"Portfolio Performance vs Single Stocks\",\n  colorset = c(\"black\", rep(\"lightgrey\", ncol(R))),\n  legend.loc = NULL\n)\n\n\n```\n\n## Subperiod Analysis of Optimized Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\n# sub perioden analyse\n\nportfolio_opt_sub <- tibble(\n  d = as.Date(index(portfolio_op_return_plot)),\n  ret  = as.numeric(portfolio_op_return_plot)\n) %>%\n  mutate(\n    month  = floor_date(d, \"month\"),\n    period = if_else(d < as.Date(\"2020-01-01\"),\n                     \"Pre-COVID\", \"Post-COVID\")\n  ) %>%\n  left_join(\n    dtb3 %>% mutate(month = floor_date(date, \"month\")),\n    by = \"month\"\n  ) %>%\n  mutate(excess = ret - rF_monthly)\n\n\nportfolio_opt_sub %>%\n  arrange(.data$date) %>%\n  mutate(price = 100 * cumprod(1 + ret)) %>%\n  ggplot(aes(date, price)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  geom_vline(xintercept = covid_date, linetype = \"dashed\", color = \"darkred\") +\n  annotate(\n  \"text\",\n  x = covid_date,\n  y = max(100 * cumprod(1 + portfolio_opt_sub$ret), na.rm = TRUE),\n  label = \"COVID-19\",\n  vjust = -0.5,\n  hjust = -0.1,\n  color = \"darkred\",\n  size = 4\n) +\n  labs(\n    title = \"Optimized (Tangency) Portfolio\",\n    x = \"Date\", y = \"Portfolio Value (Base = 100)\"\n  ) +\n  theme_minimal()\n\n# kennzahlen subperiod\nportfolio_opt_stats_sub <- portfolio_opt_sub %>%\n  group_by(period) %>%\n  summarise(\n    mean_return_pa = mean(ret, na.rm = TRUE) * 12 * 100,\n    volatility_pa  = sd(ret, na.rm = TRUE) * sqrt(12) * 100,\n    sharpe_ratio   = mean(excess, na.rm = TRUE) /\n                     sd(ret, na.rm = TRUE) * sqrt(12),\n    .groups = \"drop\"\n  )\n\nportfolio_opt_dd_sub <- portfolio_opt_sub %>%\n  arrange(d) %>%\n  mutate(\n    price = 100 * exp(cumsum(log(1 + ret))) /\n            first(exp(cumsum(log(1 + ret))))\n  ) %>%\n  group_by(period) %>%\n  summarise(\n    max_drawdown = min(price / cummax(price) - 1, na.rm = TRUE) * 100,\n    .groups = \"drop\"\n  )\n\nportfolio_opt_table_sub <- portfolio_opt_stats_sub %>%\n  left_join(portfolio_opt_dd_sub, by = \"period\") %>%\n  mutate(\n    across(where(is.numeric), round, 2)\n  )\n\nkable(\n  portfolio_opt_table_sub,\n  col.names = c(\n    \"Period\",\n    \"Ø Return (% p.a.)\",\n    \"Volatility (% p.a.)\",\n    \"Sharpe Ratio\",\n    \"Max Drawdown (%)\"\n  ),\n  caption = \"Subperiod Analysis of the Optimized (Tangency) Portfolio\"\n)\n\n```\n\n# Regression\n\n\\[PLATZHALTER\\]\n\n## Market Model and CAPM Evidence\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# marktdaten laden | https://fred.stlouisfed.org/series/NASDAQXCMP\n\nmarket_raw <- read_xlsx(\"data/market.xlsx\", sheet = \"Daily\")\n\n\n# returns berechnen\nreturns_market <- market_raw %>%\n  mutate(month = as.Date(format(observation_date, \"%Y-%m-01\"))) %>%\n  group_by(month) %>%\n  slice_tail(n=1) %>%\n  ungroup() %>%\n  select(observation_date, NASDAQXCMP) %>%\n  mutate(return_market = NASDAQXCMP / lag(NASDAQXCMP) -1, date = observation_date) %>%\n  select(date, return_market)\n\n\nreturns_reg <- returns_market %>%\n  left_join(returns_wide, by = \"date\") %>%\n  drop_na()\n\n\n# Regression\n\nstocks <- setdiff(names(returns_reg), c(\"date\", \"return_market\"))\n\nreg_output <- lapply(stocks, function(s) {\n  model <- lm(as.formula(paste(s, \"~ return_market\")), data = returns_reg)\n  tidy(model) %>%\n    filter(term %in% c(\"(Intercept)\", \"return_market\")) %>%\n    select(term, estimate, p.value) %>%\n    pivot_wider(names_from = term, values_from = c(estimate, p.value)) %>%\n    mutate(stock = s,\n           r2 = summary(model)$r.squared)\n    \n}) %>% bind_rows()\n\nreg_output <- reg_output %>%\n  rename(\n    Ticker = stock,\n    Alpha = `estimate_(Intercept)`,\n    Beta = estimate_return_market,\n    p_value_int = `p.value_(Intercept)`,\n    p_value = p.value_return_market,\n    R2 = r2\n  ) %>%\n  select(Ticker, Alpha, Beta, p_value_int, p_value, R2)\n\nreg_output %>%\n  mutate(across(where(is.numeric), ~ round(.x, 3))) %>%\n  kable()\n\n# boxplots für beta und r2\nreg_long <- reg_output %>%\n  select(Beta, R2) %>%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\")\n\np_box <- ggplot(reg_long, aes(x = metric, y = value)) +\n  geom_boxplot(\n    fill = \"#1599AB\",\n    alpha = 0.8,\n    width = 0.5\n  ) +\n  geom_jitter(width = 0.05, alpha = 0.6) +\n  labs(\n    title = \"Distribution of CAPM Estimates\",\n    x = \"\",\n    y = \"\"\n  ) +\n  theme_minimal()\np_box\n```\n\n## Multifactor Model Results\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# import fama 3 factor | https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html\nf3f <- read_csv(\"data/fama_3_factor.csv\", skip = 3, col_names = TRUE)\n\nf3f <- f3f %>%\n  rename(ym = ...1) %>%\n  mutate(date = as.Date(paste0(ym, \"01\"), format = \"%Y%m%d\"))\n\nf3f <- f3f %>% select(date, `Mkt-RF`, SMB, HML, RF) %>% filter(date >= as.Date(\"2014-08-29\"), date <= as.Date(\"2024-08-30\")) %>% mutate(across(c(`Mkt-RF`, SMB, HML, RF), ~ .x / 100))\n\n# monat und jahr aus datum extrahieren\nreturns_reg_new <- returns_reg %>%\n  mutate(ym = format(date, \"%Y-%m\"))\n\nf3f <- f3f %>%\n  mutate(ym = format(date, \"%Y-%m\"))\n\n# f3f und returns_reg_new zusammenführen\nf3f <- returns_reg_new %>%\n  left_join(f3f, by = \"ym\") %>%\n  drop_na() %>%\n  rename(Mkt_RF = `Mkt-RF`)\n\n# ticker namen extrahieren\n\nstocks_f3f <- setdiff(\n  names(f3f),\n  c(\"date.x\", \"date.y\", \"ym\", \"return_market\",\n    \"Mkt_RF\", \"SMB\", \"HML\", \"RF\")\n)\n\n\n# multiple regression durchführen\nff3_results <- lapply(stocks_f3f, function(s) {\n\n  # Excess Return der jeweiligen Aktie\n  f3f_tmp <- f3f %>%\n    mutate(excess = .data[[s]] - RF)\n\n  model <- lm(excess ~ `Mkt_RF` + SMB + HML, data = f3f_tmp)\n\n  # Koeffizienten + R² extrahieren\n  tibble(\n    Ticker = s,\n    Alpha = coef(model)[[\"(Intercept)\"]],\n    Beta_mkt = coef(model)[[\"Mkt_RF\"]],\n    Beta_smb = coef(model)[[\"SMB\"]],\n    Beta_hml = coef(model)[[\"HML\"]],\n    R2 = summary(model)$r.squared\n  )\n}) %>%\n  bind_rows()\n\n\n\nkable(ff3_results)\n\n# boxplots für beta und r2\n\nff3_results_long <- ff3_results %>%\n  select(Beta_mkt, R2) %>%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\")\n\np_box <- ggplot(ff3_results_long, aes(x = metric, y = value)) +\n  geom_boxplot(\n    fill = \"#1599AB\",\n    alpha = 0.8,\n    width = 0.5\n  ) +\n  geom_jitter(width = 0.05, alpha = 0.6) +\n  labs(\n    title = \"Distribution of CAPM Estimates\",\n    x = \"\",\n    y = \"\"\n  ) +\n  theme_minimal()\np_box\n\n```\n\n# Conclusion\n\n\\[PLATZHALTER\\]\n","srcMarkdownNoYaml":"\n\n# INTRODUCTION\n\n\\[PLATZHALTER\\]\n\n# Data and Methodology\n\n\\[PLATZHALTER\\]\n\nAnmerkungen\n\nErstellung eines neuen Dataframes mit Returns aller Aktien.\n\nCRSP gibt arithmetische Renditen aus. Diese transformieren wir in logrithmierte. Die Returns sind bereits adjusted, d.h. Dividenden sind bereits berücksichtigt.\n\nNormierte preise auf Basis der Renditen berechnen.\n\nPreise sind nicht adjustiert. Wir werden die Kurse auf Basis der Renditen plotten - alle auf 100 normieren und dann mit den returns multiplizieren (vereinfacht das adjustment um die Dividenden - wir haben monatliche returns, dividend payments fallen damit nicht immer auf den selben tag)\n\nFolgende Preise sind \"simuliert\" für den Plot. Achtung: preis startet am 29.8.2014 bei 100 die return am 29.8.2014 bezieht sich aber auf Preis(29.8.2014) / Preis(28.8.2014).\n\n```{r echo = FALSE, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(moments)\nlibrary(slider)\nlibrary(tidyquant)\nlibrary(PortfolioAnalytics)\nlibrary(PerformanceAnalytics)\nlibrary(ROI)\nlibrary(ROI.plugin.quadprog)\nlibrary(writexl)\nlibrary(broom)\n```\n\n```{r echo = FALSE, message=FALSE, warning=FALSE}\ndata_raw <- read_xlsx(\"data/stocks.xlsx\")\n# glimpse(data_raw)\n\n# risikoloser zins\ninvisible(getSymbols(\"DTB3\", src = \"FRED\"))\n\n# risikoloser zins in richtiges format bringen\ndtb3 <- tibble(\n  date = index(DTB3),\n  rate = as.numeric(DTB3)\n) %>%\n  filter(!is.na(rate)) %>%\n  filter(date >= as.Date(\"2014-08-29\"), date <= as.Date(\"2024-08-30\")) %>%\n  mutate(\n    rF_annual = rate / 100,\n    rF_monthly = (1 + rF_annual)^(1/12)-1,\n    month = as.Date(format(date, \"%Y-%m-01\"))\n    ) %>%\n  group_by(month) %>%\n  slice_tail(n = 1) %>%\n  ungroup() %>%\n  select(date, rF_monthly)\n  \n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Funkion für Darstellung der Dataframes | kann man ignorieren\n\ndataframe_fancy <- function(df) {\n  tibble(\n    Variable = names(df),\n    Datentyp = sapply(df, class),\n    Wert = sapply(df, function(x) {\n      as.character(x[!is.na(x)][1])\n    })\n  ) %>%\n    knitr::kable(\n      col.names = c(\"Variable\", \"Datentyp\", \"Wert\"),\n      align = c(\"l\", \"l\", \"l\")\n    )\n}\n\n```\n\n```{r echo = FALSE}\n# dataframe für returns\n\nreturns <- data_raw %>%\n  select(permno = PERMNO,\n         ticker = `Ticker Symbol`,\n         company = `Company Name`,\n         date = `Names Date`,\n         returns = Returns) %>%\n  arrange(ticker, date) %>%\n  mutate(returns_log = log(1 + returns))\n  \n# dataframe_fancy(returns)\n\n\n```\n\n```{r echo=FALSE}\nticker = returns %>% distinct(ticker)\n\nprices <- returns %>%\n  group_by(ticker) %>%\n  arrange(date) %>%\n  mutate(prices = 100 * exp(cumsum(returns_log)) / first(exp(cumsum(returns_log)))) %>%\n  arrange(ticker, date) %>%\n  ungroup()\n\n# dataframe_fancy(prices)\n```\n\n# Descriptive Analysis of Indiviudal Stocks\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE}\n\n\n# plot für alle aktien\nggplot(prices, aes(x = date, y = prices, color = ticker)) +\n  geom_line(linewidth = 0.5) +\n  scale_y_log10() +\n  labs(title = \"Stock Prices\",\n       x = \"Date\",\n       y = \"Prices log\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n```\n\n## Return and Risk Characteristics\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE}\nmax_drawdown <- prices %>%\n  group_by(ticker) %>%\n  mutate(\n    running_max = cummax(prices),\n    drawdown = prices / running_max - 1\n  ) %>%\n  summarise(max_drawdown = min(drawdown, na.rm=TRUE))\n\nstatistics_stocks <- returns %>%\n  group_by(ticker) %>%\n  summarise(\n    mean_return = mean(returns, na.rm = TRUE),\n    sd_return   = sd(returns, na.rm = TRUE),\n    min_return  = min(returns, na.rm = TRUE),\n    max_return  = max(returns, na.rm = TRUE)\n  ) %>%\n  left_join(max_drawdown, by = \"ticker\")\n\nstatistics_stocks %>%\n  mutate(\n    mean_return = mean_return * 100 * 12,\n    sd_return = sd_return * 100 * sqrt(12),\n    min_return = min_return * 100,\n    max_return = max_return * 100,\n    max_drawdown = max_drawdown * 100\n  ) %>%\n  kable(col.names = c(\"Ticker\", \"Ø Return (%) p.a.\", \"Std.Dev. (%) p.a.\", \"Minimum (%)\", \"Maximum (%)\", \"Max Drawdown (%)\"),\n        digits = 2)\n```\n\n## Distributional Properties of Returns\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ndistribution_stocks <- returns %>%\n  group_by(ticker) %>%\n  summarise(\n    skewness = skewness(returns_log, na.rm = TRUE),\n    kurtosis = kurtosis(returns_log, na.rm = TRUE)\n  ) %>%\n  mutate(skewness_int = case_when(\n      skewness > 0 ~ \"positively skewed\",\n      skewness == 0 ~ \"symmetric\",\n      skewness < 0 ~ \"negatively skewed\"\n      ),\n      kurtosis_int = case_when(\n        kurtosis < 0 ~ \"platykurtic\",\n        kurtosis > 0 ~ \"leptokurtic\",\n        kurtosis == 0 ~ \"norm. distributed\"\n      )\n      )\n\ndistribution_stocks %>%\n  select(ticker, skewness, skewness_int, kurtosis, kurtosis_int) %>%\n  kable(col.names = c(\"Ticker\", \"Skewness\", \"Interpretation\", \"Excess Kurtosis\", \"Interpretation\"))\n```\n\n## Time-Varying Risk and Performance\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nvola_rolling <- returns %>%\n  group_by(ticker) %>%\n  arrange(date) %>%\n  mutate(\n    roll_sd = slide_dbl(\n      returns_log,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd_annual = roll_sd * sqrt(12)\n  ) %>%\n  select(-c(\"permno\", \"company\", \"returns\", \"returns_log\"))\n\n\nggplot(vola_rolling,\n       aes(x = date, y = roll_sd_annual, group = ticker, color = ticker)) +\n  geom_line(alpha = 0.5) +\n  labs(\n    title = \"12 month rolling Volatility (annual)\",\n    x = \"Date\",\n    y = \"Rolling Volatility\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n```\n\n```{r message=FALSE, warning=FALSE, echo=FALSE}\n# Leider fehlende Werte von rF_monthly für 2024-03-28 ; 2018-03-29 ; 2021-05-28\n# Letzten Tag im Monat genommen\n\nexcess_return <- returns %>%\n  mutate(month = as.Date(format(date, \"%Y-%m-01\"))) %>%\n  left_join(\n    dtb3 %>%\n      mutate(month = as.Date(format(date, \"%Y-%m-01\"))),\n    by = \"month\"\n  ) %>%\n  mutate(excess_return = returns - rF_monthly)\n\n\nsharpe_ratio_rolling <- excess_return %>%\n  group_by(ticker) %>%\n  arrange(date.x) %>%\n  mutate(\n    roll_mean_excess = slide_dbl(\n      excess_return,\n      mean,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd = slide_dbl(\n      returns,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    sharpe_ratio_rolling = (roll_mean_excess / roll_sd) * sqrt(12)\n  ) %>%\n  ungroup()\n\nggplot(sharpe_ratio_rolling, aes(x = date.x, y = sharpe_ratio_rolling, group = ticker, color = ticker)) +\n  geom_line(alpha = 0.5) +\n  labs(title = \"12 month Rolling Sharpe Ratios\", x = \"Date\", y = \"SR (annualized)\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n\n```\n\n## Total Set of Stocks (Equally Weighted)\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE}\n# ew = equal weights\nportfolio_ew <- excess_return %>%\n  group_by(date.x) %>%\n  summarise(\n    portfolio_ew_return = mean(returns, na.rm = TRUE),\n    portfolio_ew_excess_return = mean(excess_return, na.rm = TRUE)\n  ) %>%\n  ungroup()\n\nportfolio_ew_prices <- portfolio_ew %>%\n  arrange(date.x) %>%\n  mutate(portfolio_price = 100 * exp(cumsum(log(1 + portfolio_ew_return))) / first(exp(cumsum(log(1 + portfolio_ew_return)))))\n\n# dataframe_fancy(portfolio_ew)\n# dataframe_fancy(portfolio_ew_prices)\n```\n\n```{r echo=FALSE}\nggplot() +\n  # Einzelaktien (grau, Hintergrund)\n  geom_line(\n    data = prices,\n    aes(x = date, y = prices, group = ticker),\n    color = \"grey70\",\n    alpha = 0.4,\n    linewidth = 0.5\n  ) +\n  # Portfolio (schwarz, Vordergrund)\n  geom_line(\n    data = portfolio_ew_prices,\n    aes(x = date.x, y = portfolio_price),\n    color = \"black\",\n    linewidth = 1.2\n  ) +\n  scale_y_log10() +\n  labs(\n    title = \"Stock Performance vs. Equal-Weighted Portfolio\",\n    subtitle = \"Grey lines = individual stocks, black line = equal-weighted portfolio\",\n    x = \"Date\",\n    y = \"Index (start = 100)\"\n  ) +\n  theme_minimal()\n\nreturns_wide <- returns %>%\n  group_by(ticker, date) %>%\n  summarise(returns = mean(returns, na.rm = TRUE),\n            .groups = \"drop\") %>%\n  pivot_wider(\n    names_from = ticker,\n    values_from = returns\n  ) %>%\n  arrange(date)\n\ncor_matrix <- returns_wide %>%\n  select(-date) %>%\n  cor(use = \"pairwise.complete.obs\")\n\ncor_long <- cor_matrix %>%\n  as.data.frame() %>%\n  rownames_to_column(\"Stock1\") %>%\n  pivot_longer(\n    -Stock1,\n    names_to = \"Stock2\",\n    values_to = \"Correlation\"\n  )\n\nggplot(cor_long, aes(x = Stock2, y = Stock1, fill = Correlation)) +\n  geom_tile(color = \"white\", linewidth = 0.4) +\n  geom_text(\n    aes(label = sprintf(\"%.2f\", Correlation)),\n    size = 1.5,\n    color = \"black\"\n  ) +\n  scale_fill_gradient(\n    low = \"#e5f5e0\",\n    high = \"#238b45\",\n    limits = c(-1, 1),\n    name = \"Correlation\"\n  ) +\n  labs(\n    title = \"Correlation Matrix of Monthly Stock Returns\"\n  ) +\n  theme_minimal(base_size = 11) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    axis.title = element_blank(),\n    panel.grid = element_blank()\n  )\n\n```\n\n## Return and Risk Characteristics of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo = FALSE}\nstatistics_portfolio_ew <- portfolio_ew %>%\n  summarise(\n    mean_return = mean(portfolio_ew_return, na.rm = TRUE) * 12 * 100,\n    sd_return   = sd(portfolio_ew_return, na.rm = TRUE) * sqrt(12) * 100,\n    min_return  = min(portfolio_ew_return, na.rm = TRUE) * 100,\n    max_return  = max(portfolio_ew_return, na.rm = TRUE) * 100\n  )\n\nportfolio_ew_drawdown <- portfolio_ew_prices %>%\n  arrange(date.x) %>%\n  mutate(\n    running_max = cummax(portfolio_price),\n    drawdown = portfolio_price / running_max - 1\n  ) %>%\n  summarise(max_drawdown = min(drawdown, na.rm =TRUE)) * 100\n\nstatistics_portfolio_ew <- statistics_portfolio_ew %>%\n  mutate(max_drawdown = portfolio_ew_drawdown$max_drawdown)\n\nstatistics_portfolio_ew <- statistics_portfolio_ew %>%\n  mutate(\n    sharpe_ratio = (\n      mean(portfolio_ew$portfolio_ew_return - dtb3$rF_monthly, na.rm = TRUE) /\n      sd(portfolio_ew$portfolio_ew_return, na.rm = TRUE)\n    )\n  )\n\n\n\nstatistics_portfolio_ew %>%\n  kable(\n    col.names = c(\n      \"Ø Return (% p.a.)\",\n      \"Volatility (% p.a.)\",\n      \"Minimum (%)\",\n      \"Maximum (%)\",\n      \"Max Drawdown (%)\",\n      \"Sharpe Ratio p.m.\"\n    ),\n    digits = 2\n  )\n\n```\n\n### Rolling Volatility of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo = FALSE, warning=FALSE}\nportfolio_ew_vola_rolling <- portfolio_ew %>%\n  arrange(date.x) %>%\n  mutate(\n    roll_sd = slide_dbl(\n      portfolio_ew_return,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd_annual = roll_sd * sqrt(12)\n  )\n\nggplot(portfolio_ew_vola_rolling,\n       aes(x = date.x, y = roll_sd_annual)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  labs(\n    title = \"12-Month Rolling Volatility – Equal-Weighted Portfolio\",\n    x = \"Date\",\n    y = \"Volatility (% p.a.)\"\n  ) +\n  theme_minimal()\n\n\n```\n\n### Rolling Sharpe Ratio of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo = FALSE, warning=FALSE}\nportfolio_ew_sharpe_rolling <- portfolio_ew %>%\n  arrange(date.x) %>%\n  mutate(\n    roll_mean_excess = slide_dbl(\n      portfolio_ew_excess_return,\n      mean,\n      .before = 11,\n      .complete = TRUE\n    ),\n    roll_sd = slide_dbl(\n      portfolio_ew_return,\n      sd,\n      .before = 11,\n      .complete = TRUE\n    ),\n    sharpe_12m = (roll_mean_excess / roll_sd) * sqrt(12)\n  )\n\nggplot(portfolio_ew_sharpe_rolling,\n       aes(x = date.x, y = sharpe_12m)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  labs(\n    title = \"12-Month Rolling Sharpe Ratio – Equal-Weighted Portfolio\",\n    x = \"Date\",\n    y = \"Sharpe Ratio (annualized)\"\n  ) +\n  theme_minimal()\n\n```\n\n### Subperiod Analyis of Equally Weighted Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\n# Sub period analysis\ncovid_date <- as.Date(\"2020-02-01\")\n\n# Covid crash\nggplot(portfolio_ew_prices, aes(x = date.x, y = portfolio_price)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  geom_vline(\n    xintercept = covid_date,\n    linetype = \"dashed\",\n    color = \"darkred\",\n    linewidth = 0.8\n  ) +\n  annotate(\n    \"text\",\n    x = covid_date,\n    y = max(portfolio_ew_prices$portfolio_price, na.rm = TRUE),\n    label = \"COVID-19\",\n    vjust = -0.5,\n    hjust = -0.1,\n    color = \"darkred\",\n    size = 4\n  ) +\n  labs(\n    title = \"Equal-Weighted Portfolio Performance\",\n    subtitle = \"COVID-19 period highlighted\",\n    x = \"Date\",\n    y = \"Portfolio Value (Base = 100)\"\n  ) +\n  theme_minimal()\n\n# kennzahlen subperioden\nportfolio_ew_sub <- portfolio_ew %>%\n  mutate(\n    period = if_else(\n      date.x < as.Date(\"2020-01-01\"),\n      \"Pre-COVID (2014–2019)\",\n      \"Post-COVID (2020–2024)\"\n    )\n  )\n\nportfolio_ew_stats_sub <- portfolio_ew_sub %>%\n  group_by(period) %>%\n  summarise(\n    mean_return_pa = mean(portfolio_ew_return, na.rm = TRUE) * 12 * 100,\n    volatility_pa  = sd(portfolio_ew_return, na.rm = TRUE) * sqrt(12) * 100,\n    sharpe_ratio   = mean(portfolio_ew_excess_return, na.rm = TRUE) /\n                     sd(portfolio_ew_return, na.rm = TRUE) * sqrt(12),\n    .groups = \"drop\"\n  )\n\nportfolio_ew_dd_sub <- portfolio_ew_prices %>%\n  mutate(\n    period = if_else(\n      date.x < as.Date(\"2020-01-01\"),\n      \"Pre-COVID (2014–2019)\",\n      \"Post-COVID (2020–2024)\"\n    )\n  ) %>%\n  group_by(period) %>%\n  summarise(\n    max_drawdown = min(portfolio_price / cummax(portfolio_price) - 1, na.rm = TRUE) * 100,\n    .groups = \"drop\"\n  )\n\nportfolio_ew_table_sub <- portfolio_ew_stats_sub %>%\n  left_join(portfolio_ew_dd_sub, by = \"period\") %>%\n  mutate(\n    across(where(is.numeric), round, 2)\n  )\n\nkable(\n  portfolio_ew_table_sub,\n  col.names = c(\n    \"Period\",\n    \"Ø Return (% p.a.)\",\n    \"Volatility (% p.a.)\",\n    \"Sharpe Ratio\",\n    \"Max Drawdown (%)\"\n  ),\n  caption = \"Subperiod Analysis of the Equal-Weighted Portfolio\"\n)\n\n```\n\n# Portfolio formation\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nrF_portfolio_chart = mean(dtb3$rF_monthly, na.rm = TRUE)\n\n# Portfolioanalyse mit PortfolioAnalytics\nR <- xts(\n  returns_wide %>% select(-date),\n  order.by = returns_wide$date\n)\n\n\n# portfolio objekt erstellen\nport <- portfolio.spec(colnames(R))\n\n# Voll investieren, shortselling erlaubt\nport <- add.constraint(port, type = \"full_investment\")\nport <- add.constraint(port, type = \"long_only\")\n\n# objectives definieren\nport <- add.objective(port, type = \"risk\", name = \"StdDev\")\nport <- add.objective(port, type = \"return\", name = \"mean\")\n\n# efficient frontier berechnen\nef <- create.EfficientFrontier(\n  R = R,\n  portfolio = port,\n  type = \"mean-StdDev\",\n  n.portfolios = 50\n)\n\nport_sr <- add.objective(\n  port,\n  type = \"risk_adjusted_return\",\n  name = \"SharpeRatio\",\n  arguments = list(Rf = rF_portfolio_chart)\n)\n\n# maxST = TRUE! um marktportfolio zu bestimmen\ntan <- optimize.portfolio(\n  R = R,\n  portfolio = port_sr,\n  optimize_method = \"ROI\",\n  maxSR = TRUE\n)\n\n\nchart.EfficientFrontier(\n  ef,\n  chart.tangent = TRUE,\n  match.col = \"StdDev\",\n  risk.col = \"StdDev\",\n  return.col = \"mean\",\n  chart.assets = TRUE,\n  chart.CML = TRUE,\n  rf = rF_portfolio_chart,\n  col = \"darkred\"\n)\n\n\n# Gewichte\nweights_tangential_portfolio <- as.data.frame(extractWeights(tan)) %>% rownames_to_column(var =\"ticker\")\ncolnames(weights_tangential_portfolio) <- c(\"Ticker\", \"Weights\")\n\n\n# Rendite und vola\nstats_tangential_portfolio <- as.data.frame(extractObjectiveMeasures(tan))\nrownames(stats_tangential_portfolio) <- \"Market Portfolio p.m.\"\ncolnames(stats_tangential_portfolio) <- c(\"St. Dev.\", \"Return\")\n\n# rf ist funktion, muss definiert werden\nrf_SR <- 0.001332711\n\nSharpeRatio = (as.numeric(extractObjectiveMeasures(tan)$mean) - rf_SR) / as.numeric(extractObjectiveMeasures(tan)$StdDev)\n\nstats_tangential_portfolio$`Sharpe Ratio` = SharpeRatio\n\nstats_tangential_portfolio <- rbind(\n  stats_tangential_portfolio,\n  \"Market Portfolio p.a.\" = c(\n    stats_tangential_portfolio$`St. Dev.` * sqrt(12),\n    (1 + stats_tangential_portfolio$Return)^(12)-1,\n    stats_tangential_portfolio$`Sharpe Ratio` * sqrt(12))\n  )\n\n# output als tabelle\nkable(stats_tangential_portfolio)\n\n\n# tabelle für gewichte\nh <- ceiling(nrow(weights_tangential_portfolio)/2)\n\nkable(\n  cbind(weights_tangential_portfolio[1:h, ], weights_tangential_portfolio[(h+1):nrow(weights_tangential_portfolio), ][1:h, ]),\n  col.names = c(\"Ticker\",\"Weight\",\"Ticker\",\"Weight\")\n)\n\n\n# Unterschiedliche Lösungen in Excel und Portfolioanalytics. Grund: Gewichtungen sind anders\n# (solve(cov(R)) %*% (colMeans(R)-rf_SR)) / sum((solve(cov(R)) %*% (colMeans(R)-rf_SR)))\n\n\n\n```\n\n## Performance of Optimized Portfolio vs Single Stocks\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nportfolio_op_return_plot <- Return.portfolio(\n  R,\n  weights = extractWeights(tan),\n  rebalance_on = NA\n)\n\n\ncharts.PerformanceSummary(\n  R = merge(portfolio_op_return_plot, R)[\"2014-08-29/2024-08-30\"],\n  main = \"Portfolio Performance vs Single Stocks\",\n  colorset = c(\"black\", rep(\"lightgrey\", ncol(R))),\n  legend.loc = NULL\n)\n\n\n```\n\n## Subperiod Analysis of Optimized Portfolio\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\n# sub perioden analyse\n\nportfolio_opt_sub <- tibble(\n  d = as.Date(index(portfolio_op_return_plot)),\n  ret  = as.numeric(portfolio_op_return_plot)\n) %>%\n  mutate(\n    month  = floor_date(d, \"month\"),\n    period = if_else(d < as.Date(\"2020-01-01\"),\n                     \"Pre-COVID\", \"Post-COVID\")\n  ) %>%\n  left_join(\n    dtb3 %>% mutate(month = floor_date(date, \"month\")),\n    by = \"month\"\n  ) %>%\n  mutate(excess = ret - rF_monthly)\n\n\nportfolio_opt_sub %>%\n  arrange(.data$date) %>%\n  mutate(price = 100 * cumprod(1 + ret)) %>%\n  ggplot(aes(date, price)) +\n  geom_line(color = \"black\", linewidth = 1) +\n  geom_vline(xintercept = covid_date, linetype = \"dashed\", color = \"darkred\") +\n  annotate(\n  \"text\",\n  x = covid_date,\n  y = max(100 * cumprod(1 + portfolio_opt_sub$ret), na.rm = TRUE),\n  label = \"COVID-19\",\n  vjust = -0.5,\n  hjust = -0.1,\n  color = \"darkred\",\n  size = 4\n) +\n  labs(\n    title = \"Optimized (Tangency) Portfolio\",\n    x = \"Date\", y = \"Portfolio Value (Base = 100)\"\n  ) +\n  theme_minimal()\n\n# kennzahlen subperiod\nportfolio_opt_stats_sub <- portfolio_opt_sub %>%\n  group_by(period) %>%\n  summarise(\n    mean_return_pa = mean(ret, na.rm = TRUE) * 12 * 100,\n    volatility_pa  = sd(ret, na.rm = TRUE) * sqrt(12) * 100,\n    sharpe_ratio   = mean(excess, na.rm = TRUE) /\n                     sd(ret, na.rm = TRUE) * sqrt(12),\n    .groups = \"drop\"\n  )\n\nportfolio_opt_dd_sub <- portfolio_opt_sub %>%\n  arrange(d) %>%\n  mutate(\n    price = 100 * exp(cumsum(log(1 + ret))) /\n            first(exp(cumsum(log(1 + ret))))\n  ) %>%\n  group_by(period) %>%\n  summarise(\n    max_drawdown = min(price / cummax(price) - 1, na.rm = TRUE) * 100,\n    .groups = \"drop\"\n  )\n\nportfolio_opt_table_sub <- portfolio_opt_stats_sub %>%\n  left_join(portfolio_opt_dd_sub, by = \"period\") %>%\n  mutate(\n    across(where(is.numeric), round, 2)\n  )\n\nkable(\n  portfolio_opt_table_sub,\n  col.names = c(\n    \"Period\",\n    \"Ø Return (% p.a.)\",\n    \"Volatility (% p.a.)\",\n    \"Sharpe Ratio\",\n    \"Max Drawdown (%)\"\n  ),\n  caption = \"Subperiod Analysis of the Optimized (Tangency) Portfolio\"\n)\n\n```\n\n# Regression\n\n\\[PLATZHALTER\\]\n\n## Market Model and CAPM Evidence\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# marktdaten laden | https://fred.stlouisfed.org/series/NASDAQXCMP\n\nmarket_raw <- read_xlsx(\"data/market.xlsx\", sheet = \"Daily\")\n\n\n# returns berechnen\nreturns_market <- market_raw %>%\n  mutate(month = as.Date(format(observation_date, \"%Y-%m-01\"))) %>%\n  group_by(month) %>%\n  slice_tail(n=1) %>%\n  ungroup() %>%\n  select(observation_date, NASDAQXCMP) %>%\n  mutate(return_market = NASDAQXCMP / lag(NASDAQXCMP) -1, date = observation_date) %>%\n  select(date, return_market)\n\n\nreturns_reg <- returns_market %>%\n  left_join(returns_wide, by = \"date\") %>%\n  drop_na()\n\n\n# Regression\n\nstocks <- setdiff(names(returns_reg), c(\"date\", \"return_market\"))\n\nreg_output <- lapply(stocks, function(s) {\n  model <- lm(as.formula(paste(s, \"~ return_market\")), data = returns_reg)\n  tidy(model) %>%\n    filter(term %in% c(\"(Intercept)\", \"return_market\")) %>%\n    select(term, estimate, p.value) %>%\n    pivot_wider(names_from = term, values_from = c(estimate, p.value)) %>%\n    mutate(stock = s,\n           r2 = summary(model)$r.squared)\n    \n}) %>% bind_rows()\n\nreg_output <- reg_output %>%\n  rename(\n    Ticker = stock,\n    Alpha = `estimate_(Intercept)`,\n    Beta = estimate_return_market,\n    p_value_int = `p.value_(Intercept)`,\n    p_value = p.value_return_market,\n    R2 = r2\n  ) %>%\n  select(Ticker, Alpha, Beta, p_value_int, p_value, R2)\n\nreg_output %>%\n  mutate(across(where(is.numeric), ~ round(.x, 3))) %>%\n  kable()\n\n# boxplots für beta und r2\nreg_long <- reg_output %>%\n  select(Beta, R2) %>%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\")\n\np_box <- ggplot(reg_long, aes(x = metric, y = value)) +\n  geom_boxplot(\n    fill = \"#1599AB\",\n    alpha = 0.8,\n    width = 0.5\n  ) +\n  geom_jitter(width = 0.05, alpha = 0.6) +\n  labs(\n    title = \"Distribution of CAPM Estimates\",\n    x = \"\",\n    y = \"\"\n  ) +\n  theme_minimal()\np_box\n```\n\n## Multifactor Model Results\n\n\\[PLATZHALTER\\]\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# import fama 3 factor | https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html\nf3f <- read_csv(\"data/fama_3_factor.csv\", skip = 3, col_names = TRUE)\n\nf3f <- f3f %>%\n  rename(ym = ...1) %>%\n  mutate(date = as.Date(paste0(ym, \"01\"), format = \"%Y%m%d\"))\n\nf3f <- f3f %>% select(date, `Mkt-RF`, SMB, HML, RF) %>% filter(date >= as.Date(\"2014-08-29\"), date <= as.Date(\"2024-08-30\")) %>% mutate(across(c(`Mkt-RF`, SMB, HML, RF), ~ .x / 100))\n\n# monat und jahr aus datum extrahieren\nreturns_reg_new <- returns_reg %>%\n  mutate(ym = format(date, \"%Y-%m\"))\n\nf3f <- f3f %>%\n  mutate(ym = format(date, \"%Y-%m\"))\n\n# f3f und returns_reg_new zusammenführen\nf3f <- returns_reg_new %>%\n  left_join(f3f, by = \"ym\") %>%\n  drop_na() %>%\n  rename(Mkt_RF = `Mkt-RF`)\n\n# ticker namen extrahieren\n\nstocks_f3f <- setdiff(\n  names(f3f),\n  c(\"date.x\", \"date.y\", \"ym\", \"return_market\",\n    \"Mkt_RF\", \"SMB\", \"HML\", \"RF\")\n)\n\n\n# multiple regression durchführen\nff3_results <- lapply(stocks_f3f, function(s) {\n\n  # Excess Return der jeweiligen Aktie\n  f3f_tmp <- f3f %>%\n    mutate(excess = .data[[s]] - RF)\n\n  model <- lm(excess ~ `Mkt_RF` + SMB + HML, data = f3f_tmp)\n\n  # Koeffizienten + R² extrahieren\n  tibble(\n    Ticker = s,\n    Alpha = coef(model)[[\"(Intercept)\"]],\n    Beta_mkt = coef(model)[[\"Mkt_RF\"]],\n    Beta_smb = coef(model)[[\"SMB\"]],\n    Beta_hml = coef(model)[[\"HML\"]],\n    R2 = summary(model)$r.squared\n  )\n}) %>%\n  bind_rows()\n\n\n\nkable(ff3_results)\n\n# boxplots für beta und r2\n\nff3_results_long <- ff3_results %>%\n  select(Beta_mkt, R2) %>%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\")\n\np_box <- ggplot(ff3_results_long, aes(x = metric, y = value)) +\n  geom_boxplot(\n    fill = \"#1599AB\",\n    alpha = 0.8,\n    width = 0.5\n  ) +\n  geom_jitter(width = 0.05, alpha = 0.6) +\n  labs(\n    title = \"Distribution of CAPM Estimates\",\n    x = \"\",\n    y = \"\"\n  ) +\n  theme_minimal()\np_box\n\n```\n\n# Conclusion\n\n\\[PLATZHALTER\\]\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":600,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"group_assignment.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","editor":"visual","title":"group_assignment"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":[]}